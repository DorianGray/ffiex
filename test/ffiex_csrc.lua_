local ffi = require 'ffiex.init'
local util = require 'ffiex.util'
if ffi.os == 'Linux' then
	ffi.path("/usr/include/linux", true)
end
-- add local path
ffi.path "./test/myheaders"
ffi.cdef [[
	#include <sys/stat.h>
	#include <unistd.h>
	#include <sys/syscall.h>
	int stat64(const char *path, struct stat *sb);
]]
ffi.cdef "#include <time.h>"

local ncall = 0
local compile_opt = {
	cc = "gcc", 
	extra = {"-D_MYDEF", "-D_MYDEF2=101", "-O2", "-Wall"},
	cache_callback = function (name, code, file, search)
		-- print('cacher', name, code, file, search)
		local st = ffi.new('struct stat[1]')
		if ffi.os == "OSX" then
			assert(0 == ffi.C.syscall(ffi.defs.SYS_stat64, file, st), "stat call fails")
			print(file..':modified@'..tostring(st[0].st_size).."|"..tostring(st[0].st_mtimespec.tv_sec))
		elseif ffi.os == "Linux" then
			assert(0 == ffi.C.syscall(ffi.defs.SYS_stat, file, st), "stat call fails")
			print(file..':modified@'..tostring(st[0].st_size).."|"..tostring(st[0].st_mtim.tv_sec))
		else
			assert(false, 'unsupported os:'..ffi.os)
		end
		if ncall < 2 then
			assert(name == 'test')
			assert(file:find('ffiex.csrc.lua'), "file name wrong:" .. file)
		elseif ncall < 4 then
			assert(name == './test/foo.c')
			assert(file:find('test/foo.c'), "file name wrong:" .. file)
		elseif ncall < 6 then
			assert(name == 'test2', "name wrong:"..name)
			assert(file:find('ffiex.csrc.lua'), "file name wrong:" .. file)
		end
		if (ncall % 2) == 0 then
			assert(search, "search should be true (because search object file from cache)")
		elseif (ncall % 2) == 1 then
			assert(not search, "search should be false (because caching object file mode)")
		end	
		ncall = (ncall + 1)
	end
}


return function (builder, setup)
	print("----------- test "..builder)
	compile_opt.cc = builder
	if setup then
		setup()
	end
	ffi.copt(compile_opt)
	ncall = 0
	local lib,ext = ffi.csrc('test', [[
	#if defined(__GNUC__)
	#include <stdio.h>
	#include <stdlib.h>
	#else // use tcc original libc header.
	#include <tcclib.h>
	#endif
	#include <stdbool.h>
	#include "my.h"
	#if defined(_MYDEF)
	#define GEN_ID(x, y) (x + y)
	#else
	#define GEN_ID(x, y) (x * y)
	#endif
	#define MYID (_MYDEF2)
	extern void hello_csrc(int id, char *buffer) { sprintf(buffer, "id:%d", id); }
	extern bool gen_id_test(int x, int y, int r) { return r == GEN_ID(x, y); }
	void export(int id) { printf("%d", id); }
	static inline void not_export(int id) { 
		printf("it should not export"); 	
	}
	]])
	assert(lib, "build error:"..tostring(ext))

	local msg = ffi.new("char[256]")
	lib.hello_csrc(ffi.defs.MYID, msg)
	assert("id:101" == ffi.string(msg))
	lib.hello_csrc(ffi.defs.GEN_ID(10, 20), msg)
	assert("id:30" == ffi.string(msg))
	assert(lib.gen_id_test(11, 22, ffi.defs.GEN_ID(11, 22)))
	lib.hello_csrc(ffi.defs.MY_MACRO(2), msg)
	assert("id:246" == ffi.string(msg))
	assert(lib.export);
	local ok, r = pcall(function ()
		return lib.not_export(100)
	end)
	assert(not ok);


	local lib2,ext2 = ffi.csrc('./test/foo.c')
	assert(lib2.footest(ffi.defs.FOO_ID) == (777 * 2))



	local lib3,ext3 = ffi.csrc('test2', [[
	void bar(int id) { return id }
	]])

	assert(not lib3, "should be nil due to compile error")
end
